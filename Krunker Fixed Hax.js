// ==UserScript==
// @name         KrunkerJava Plus ùìßv5
// @namespace   KrunkerJava Plus ùìßv5
// @version      5.0
// @description  Get first place in game!
// @author       Krunker Jav
// @iconURL      data:image/jpeg;base64,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
// @require      https://raw.githubusercontent.com/ygoe/msgpack.js/master/msgpack.min.js
// @match        *://krunker.io/*
// @run-at       document-start
// @grant        none
// ==/UserScript==

/* eslint-disable no-caller */

(function() {
    // Variables
    var frameCount = 0;
    var vars = new Map();
    var script;
    var GUI;
    var showMenu = true;
    var menuDirty = true;
    var features = [];
    var updatedFeat = new Map();
    var positions = new Map();
    var downKeys = new Set();
    var objectDirty = false;
    var mouseDownL = false, mouseDownM = false, mouseDownR = false;
    var keyDown = (key) => downKeys.has(key);
    var isProxy = Symbol("isProxy");
    const twoPI = Math.PI * 2;
    const halfPI = Math.PI / 2;

    // Initialization
    function initialize() {

        addListener(document, "mousedown", event =>{
            const Left=0, Middle=1, Right=2;
            switch(event.button) {
                case Left: mouseDownL = true; break;
                case Middle: mouseDownM = true; break;
                case Right: mouseDownR = true; break;
                default: break;
            }
        });

        addListener(document, "mouseup", event =>{
            const Left=0, Middle=1, Right=2;
            switch(event.button) {
                case Left: mouseDownL = false; break;
                case Middle: mouseDownM = false; break;
                case Right: mouseDownR = false; break;
                default: break;
            }
        });

        addListener(document, "keyup", event => {
            if (downKeys.has(event.code)) downKeys.delete(event.code)
        });

        addListener(document, "keydown", event => {
            if ('INPUT' == document.activeElement.tagName || !window.endUI && window.endUI.style.display) return;
            switch (event.code) {
                case 'F1':
                    event.preventDefault();
                    showMenu ^= 1;
                    window.SOUND.play('tick_0', 0.1);
                    menuDirty = showMenu;
                    break;
                case 'F2':
                    saveAs("game_" + getVersion() + ".js", script);
                    break;
                default:
                    if (!downKeys.has(event.code)) downKeys.add(event.code);
                    for (const feature of features) {
                        if (feature && "Digit" + feature.key == event.code) {
                            if (feature.container.length) onUpdated(feature);
                            else if (typeof feature.myFunction === "function") feature.myFunction();
                        }
                    }
                    break;
            }
        });

        // GUI Init
        GUI = document.getElementById("myGUI");
        if (GUI == null) {
            GUI = document.createElement('div');
            GUI.id = "myGUI";
            GUI.style = "float:left;width:100%;background-color: rgba(0,0,0,0.25);border-radius:5%;text-align:right;line-height:0.8;margin-top:5%;";
        }

        //Add Features
        newFeature('Chams', "3", ['Off', 'On']);
        newFeature('WireFrame', "4", ['Off', 'On']);
        newFeature('Names', "5", ['Off', 'On']);
        newFeature('Bhop', "6", ['Off', 'Auto Jump', 'Key Jump', 'Auto Slide', 'Key Slide']);
        newFeature('AutoReload', "7", ['Off', 'On']);
        newFeature('AutoAim', "8", ['Off', 'Assist', 'Silent', 'IDGAF']);
        newFeature('Wallbangs', "9", ['Off', 'On']);

    }

    // Main Render Loop
    function RENDER(three, utils, colors, config, overlay, scale, game, controls, renderer, me, delta) {

        frameCount++; //frame timer
        if (frameCount >= 100000) {
            frameCount = 0;
        }

        //if (frameCount % 1000 == 0) {
        //    console.log("FRAME ", frameCount)
        //}

        if(me && renderer.scene) {
            //GUI Update
            const topLeft = document.getElementById("topLeftHolder");
            if (topLeft && GUI) {
                if (!topLeft.contains(GUI)) {
                    topLeft.appendChild(GUI);
                } else if (showMenu) {
                    if (menuDirty) {
                        menuDirty = false;
                        GUI.innerHTML = "<br><h4 style='text-align:center;color:#1E90FF;'>Krunker Java Plus ùìß Fixed</h4><hr>";
                        for (const feature of features) {
                            GUI.innerHTML += `<h5><span style='float:left;margin-left:10%;color:rgba(255,193,72,255)'>${feature.key}</span> <span style='float:left;margin-left:10%;color:rgba(255,255,255,255)'>${feature.name}</span> <span style=float:all;margin-right:10%;margin-left:10%;color:${feature.valueStr == "On" ? "#B2F252" : feature.valueStr == "Off" ? "#FF4444" : "#999EA5"};'>${feature.valueStr}</span></h5>`;
                        }
                        GUI.innerHTML += "<br>";
                    }
                } else if (GUI.innerHTML) GUI.innerHTML = null;
            }
            for (let[name, feature] of updatedFeat) {
                updatedFeat.delete(name);
            }

            // Rendering Related Features Update...

            // NameTags
            let getIsFriendly = (entity) => (me && me.team ? me.team : me.spectating ? 0x1 : 0x0) == entity.team;
            let getInView = (entity) => (null == game[vars.get("canSee").val](me, entity.pos.x, entity.pos.y, entity.pos.z, 10));
            const featureNames = getFeature('Names');
            game.players.list.filter(x => {
                return x && x.active && !x[vars.get("isYou").val] && x.hasOwnProperty('pos');
            }).forEach((player, index, array) => {
                player[vars.get("inView").val] = featureNames.value ? player.active : getIsFriendly(player) ? player.active : getInView(player);
            })

            // Chams / WireFrame
            const featureChams = getFeature('Chams');
            const featureWire = getFeature('WireFrame');
            for (const obj of renderer.scene.children) {
                if (obj instanceof three.Object3D) {
                    if (obj.name && obj.name.startsWith("playermap")) {
                        obj.visible = featureChams.value ? true : false;
                        obj.traverse(( child ) => {
                            if (child && child.type =="Mesh") {
                                child.material.depthTest = featureChams.value ? false : true;
                                child.material.opacity = featureChams.value ? 0.85 : 1.0;
                                child.material.transparent = featureChams.value ? true : false;
                                child.material.fog = featureChams.value ? false : true;
                                child.material.emissive.r = featureChams.value ? 0.25 : 0;
                                //child.material.emissive.g = featureChams.value ? 0.55 : 0;
                                child.material.emissive.b = featureChams.value ? 0.55 : 0;
                                child.material.wireframe = featureWire.value ? true : false;
                            }
                        })
                    }
                }
            }

            // camLookAt
            const featureAutoAim = getFeature('AutoAim');
            if (controls && (featureAutoAim.value > 1 || featureAutoAim.value == 1 && mouseDownR)) {
                if (void 0 == game.controls.camTarget) {
                    Object.defineProperty(controls, 'camTarget', { value: null });
                }
                else if (featureAutoAim.value == 1 && mouseDownR && controls.camTarget !== null || featureAutoAim.value > 1 && controls.camTarget !== null) {
                    const pchObjc = controls[vars.get("pchObjc").val];
                    pchObjc.rotation.x = controls.camTarget.xD;
                    pchObjc.rotation.x = Math.max(-halfPI, Math.min(halfPI, pchObjc.rotation.x));
                    controls.object.rotation.y = controls.camTarget.yD;
                    controls.yDr = pchObjc.rotation.x % Math.PI;
                    controls.xDr = controls.object.rotation.y % Math.PI;
                }
            }

            // inputs
            /*
            const isn = 0, speed = 1, ydir = 2, xdir = 3, move = 4, shoot = 5, scope = 6, jump = 7, crouch = 8, reload = 9, weaponKey = 10, weaponSwap = 11;
            if (controls.tmpInpts.length) {
                let input = controls.tmpInpts.shift();
                input[scope] = mouseDownR
                input[shoot] = mouseDownL
                const featureReload = getFeature('AutoReload');
                if (featureReload.value) {
                    let ammoLeft = me[vars.get("ammos").val][me[vars.get("weaponIndex").val]];
                    if (ammoLeft <= 1) {
                        input[reload] = 1;
                    }
                }
                frame ++;
                if (frame >= delta * 10) {
                    frame = 0;
                    //me.resetInputs();
                    me.inputs.pop();
                    me.inputs.push(input)
                }
            }*/
        }
    }

    // Main Input Loop
    function INPUTS(three, utils, colors, config, overlay, me, input, game, recon, lock) {
        const KEY = {
            frame : 0,
            delta : 1,
            xdir : 2,
            ydir : 3,
            moveDir : 4,
            shoot : 5,
            scope : 6,
            jump : 7,
            crouch : 8,
            reload : 9,
            weaponScroll : 10,
            weaponSwap : 11,
            moveLock : 12
        }

        //Auto Reload
        const featureReload = getFeature('AutoReload');
        if (featureReload.value) {
            let ammoLeft = me[vars.get("ammos").val][me[vars.get("weaponIndex").val]];
            if (ammoLeft <= 0) {
                input[KEY.reload] = 1;
            }
        }

        // bHop / slide
        const featureBhop = getFeature('Bhop');
        if (featureBhop && featureBhop.value) {
            if (keyDown("Space") || featureBhop.value !== 2 && featureBhop.value !== 4) {
                game.controls.keys[game.controls.jumpKey] ^= 1;
                game.controls.keys[game.controls.crouchKey] = (me.yVel < -0.04 && me.canSlide) && featureBhop.value !== 1 && featureBhop.value !== 2 ? 1 : 0;
            }
        }

        let camLookAt = (pos) => {
            if (pos === null || (pos.x + pos.y + pos.z) == 0) return void(game.controls.camTarget = null);
            let xdir = getXDire(game.controls.object.position.x, game.controls.object.position.y, game.controls.object.position.z, pos.x, pos.y, pos.z);
            let ydir = getDir(game.controls.object.position.z, game.controls.object.position.x, pos.z, pos.x);
            game.controls.camTarget = {
                xD:xdir,
                yD: ydir,
                x: pos.x + config.camChaseDst * Math.sin(ydir) * Math.cos(xdir),
                y: pos.y - config.camChaseDst * Math.sin(xdir),
                z: pos.z + config.camChaseDst * Math.cos(ydir) * Math.cos(xdir)
            }
        }

        let getIsFriendly = (entity) => (me && me.team ? me.team : me.spectating ? 0x1 : 0x0) == entity.team;
        let getInView = (entity) => (null == game[vars.get("canSee").val](me, entity.pos.x, entity.pos.y, entity.pos.z));
        let enemies = game.players.list.filter(x => {
            return x.active && !x[vars.get("isYou").val] && !getIsFriendly(x)
        })

        enemies.forEach((enemy, index, array) => {
            let key = enemy.sid; //game.players.indexBySid(enemy.sid);
            if (positions.has(key)) {
                let pos = positions.get(key);
                enemy.pos = new three.Vector3(pos.x, pos.y + enemy.height - config.cameraHeight - enemy[vars.get("crouchVal").val] * config.crouchDst, pos.z)
            }
        })

        let pchObjc = game.controls[vars.get("pchObjc").val];
        let ty = game.controls.object.rotation.y;
        let tx = pchObjc.rotation.x;

        let target = enemies.filter(x => {
            return x.hasOwnProperty('pos') && getInView(x)
        }).sort((p1, p2) => p1.pos.distanceToSquared(me) - p2.pos.distanceToSquared(me)).shift();

        // bHop / slide
        const featureAutoAim = getFeature('AutoAim');
        //newFeature('AutoAim', "8", ['Off', 'Assist', 'Silent', 'IDGAF']);
        if (featureAutoAim.value && target) {
            if (featureAutoAim.value !== 2) camLookAt(target.pos);
            if (featureAutoAim.value > 1) {
                if (me.weapon[vars.get("nAuto").val] && me[vars.get("didShoot").val]) {
                    input[KEY.shoot] = 0;
                } else if (!me[vars.get("aimVal").val]) {
                    input[KEY.scope] = 1;
                    input[KEY.shoot] = 1;
                } else {
                    input[KEY.scope] = 1;
                }
            }

            ty = getDir(game.controls.object.position.z, game.controls.object.position.x, target.pos.z, target.pos.x);
            tx = getXDire(game.controls.object.position.x, game.controls.object.position.y, game.controls.object.position.z, target.pos.x, target.pos.y, target.pos.z);
            tx -= (0.3 + me.recoilForce) * me[vars.get("recoilAnimY").val];
        }
        else {
            camLookAt(null);
            //input[KEY.scope] = 0;
        }
        // silent aim
        if (featureAutoAim.value) {
            input[KEY.ydir] = (tx % twoPI).toFixed(3) * 0x3e8;
            input[KEY.xdir] = (ty % twoPI).toFixed(3) * 0x3e8;
        }
    }


    // Set Variable Object Entries
    let setVars = function() {
        vars
        .set("xDire", {regex:/this\['(\w+)']=\w+\['round']\(0x3\),this\['\w+']=\w+\['round']\(0x3\)/,pos:1})
        .set("yDire", {regex:/this\['(\w+)']>Math\['PI']\/0x2\?this\['\w+']=Math\['PI']\/0x2/,pos:1})
        .set("isYou", {regex:/this\['\w+']=k,this\['(\w+)']=w,this\['\w+']=!0x0/,pos:1})
        .set("inView", {regex:/if\(!\w+\['(\w+)']\)continue/,pos:1})
        .set("ammos", {regex:/\['noReloads']\|\|!\w\['\w+']&&\w\['(\w+)']/,pos:1})
        .set("weaponIndex", {regex:/\['noReloads']\|\|!\w\['\w+']&&\w\['\w+']\[\w\['(\w+)']]/,pos:1})
        .set("procInputs", {regex:/this\['(\w+)']=function\((\w+),(\w+),\w+,\w+\){(this)\['recon']/,pos:1})
        .set("swapWeapon", {regex:/\w+\['(\w+)']\(this,null,null,void 0x0,0x0,\w+\):\w+\[0xa]&&\w+\['\w+']\(this,\w+\[0xa],!0x1,void 0x0,void 0x0,\w+\)/,pos:1})
        .set("aimVal", {regex:/&&0x1==\w\['(\w+)']&&!\w/,pos:1})
        .set("pchObjc", {regex:/0x0,this\['(\w+)']=new \w+\['Object3D']\(\),this/,pos:1})
        .set("didShoot", {regex:/--,\w+\['(\w+)']=!0x0/,pos:1})
        .set("nAuto", {regex:/'(\w+)':!0x0,'burst':/,pos:1})
        .set("crouchVal", {regex:/this\['(\w+)']\+=\w\['crouchSpeed']\*\w+,0x1<=this\['\w+']/,pos:1})
        .set("recoilAnimY", {regex:/\w*1,this\['\w+'\]=\w*0,this\['\w+'\]=\w*0,this\['\w+'\]=\w*1,this\['\w+'\]=\w*1,this\['\w+'\]=\w*0,this\['\w+'\]=\w*0,this\['(\w+)'\]=\w*0,this\['\w+'\]=\w*0,this\['\w+'\]=\w*0,this\['\w+'\]=\w*0,/,pos:1})
        .set("canSee", {regex:/this\['(\w+)']=function\(\w+,\w+,\w+,\w+,\w+,\w+\){if\(!\w+\)return!0x1;/,pos:1})

        for (const [name, object] of vars.entries()) {
            let result = object.regex.exec(script);
            if ( result ) {
                object.val = result[object.pos];
                console.log("found: ", name, " at ", result.index, " value: ", object.val);
            } else {
                object.val = null;
                alert("Failed to find ", name);
            }
        }
    }

    // Decode The Vries
    let decodeText = function(str, array, xor) {
        for (var i = 0, il = array.byteLength; i < il; i ++) {
            str += String.fromCharCode(array.getUint8(i) ^ xor);
        }
        try {
            return decodeURIComponent( escape( str ) );
        } catch ( e ) {
            return str;
        }
    }

    // Get the game patch number
    let getVersion = function() {
		const elems = document.getElementsByClassName('terms');
		const version = elems[elems.length - 1].innerText;
        return version;
	}

    // Save Data to Disk
    let saveAs = function(name, data) {
        let blob = new Blob([data], {type: 'text/plain'});
        let el = window.document.createElement("a");
        el.href = window.URL.createObjectURL(blob);
        el.download = name;
        document.body.appendChild(el);
        el.click();
        document.body.removeChild(el);
    }

    // Check if Something is Defined
    let isDefined = function(object) {
        return void 0 !== object;
    }

    // Check if Something is a type
    let isType = function(item, type) {
        return typeof item === type;
    }

    // Various utility functions...
    let getD3D = function(x1, y1, z1, x2, y2, z2) {
        var dx = x1 - x2;
        var dy = y1 - y2;
        var dz = z1 - z2;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };
    let getAngleDst = function (a, b) {
        return Math.atan2(Math.sin(b - a), Math.cos(a - b));
    };
    let getXDire = function(x1, y1, z1, x2, y2, z2) {
        var h = Math.abs(y1 - y2);
        var dst = getD3D(x1, y1, z1, x2, y2, z2);
        return (Math.asin(h / dst) * ((y1 > y2)?-1:1));
    };
    let getDir = function (x1, y1, x2, y2) {
        return Math.atan2(y1 - y2, x1 - x2);
    };
    let lineInRect = function(lx1, lz1, ly1, dx, dz, dy, x1, z1, y1, x2, z2, y2) {
        var t1 = (x1 - lx1) * dx;
        var t2 = (x2 - lx1) * dx;
        var t3 = (y1 - ly1) * dy;
        var t4 = (y2 - ly1) * dy;
        var t5 = (z1 - lz1) * dz;
        var t6 = (z2 - lz1) * dz;
        var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        if (tmax < 0) return false;
        if (tmin > tmax) return false;
        return tmin;
    };

    // MutationObserver
    let addObserver = function(elm, check, callback, onshow = true) {
        return new MutationObserver((mutationsList, observer) => {
            if (check == 'src' || onshow && mutationsList[0].target.style.display == 'block' || !onshow) {
                callback(mutationsList[0].target);
            }
        }).observe(elm, check == 'childList' ? {
            childList: true
        } : {
            attributes: true,
            attributeFilter: [check]
        });
    }

    // Event Listener
    let addListener = function(elm, type, callback = null) {
        if (!isDefined(elm)) { alert("Failed creating " + type + "listener"); return }
        elm.addEventListener(type, event => callback(event));
    }

    // Storage
    let canStore = (typeof(Storage) !== "undefined");
    let saveVal = function(name, val) {
        if (canStore) localStorage.setItem(name, val);
    }
    let deleteVal = function(name) {
        if (canStore) localStorage.removeItem(name);
    }
    let getSavedVal = function(name) {
        if (canStore) return localStorage.getItem(name);
        return null;
    }

    //Features
    let newFeature = (name, keyBind, array, myFunction = null) => {
        const cStruct = (...keys) => ((...v) => keys.reduce((o, k, i) => {
            o[k] = v[i];
            return o
        }, {}));
        let item = [];
        const myStruct = cStruct('name', 'key', 'value', 'valueStr', 'container', 'myFunction')
        const value = parseInt(getSavedVal("utilities_" + name) || 0);
        const feature = myStruct(name, keyBind, value, array.length ? array[value] : '', array, myFunction);
        if (array.length || myFunction) features.push(feature);
        item.push(feature);
        return item;
    }

    let getFeature = (name) => {
        for (const feature of features) {
            if (feature.name.toLowerCase() === name.toLowerCase()) {
                return feature;
            }
        }
        return null;
    }

    let onUpdated = (feature) => {
        window.SOUND.play('tick_0', 0.1);
        if (feature.container.length) {
            feature.value += 1;
            if (feature.value > feature.container.length - 1) {
                feature.value = 0;
            }
            feature.valueStr = feature.container[feature.value];
            saveVal("utilities_" + feature.name, feature.value);
        }
        if (feature.container.length == 2 && feature.container[0] == 'Off' && feature.container[1] == 'On') {
            console.debug(feature.name, " is now ", feature.valueStr);
            if (feature.name == "Wallbangs") objectDirty = true;
        }

        if (!updatedFeat.has(feature.name)) {
            console.debug(feature.name, " - Update Pending ")
            updatedFeat.set(feature.name, feature);
        }

        menuDirty = true;
    }

    // Exploit game...
    let hookChain = function(three, utils, colors, config, overlay) {

        overlay.render = new Proxy(overlay.render, {
            apply: function(target, that, [scale, game, controls, renderer, me, delta]) {

                if (me && me.active) {

                    if (!me[vars.get("procInputs").val][isProxy]) {
                        me[vars.get("procInputs").val] = new Proxy(me[vars.get("procInputs").val], {
                            apply: function(target, that, [input, game, recon, lock]) {
                                if (that) INPUTS(three, utils, colors, config, overlay, that, input, game, recon, lock)
                                return target.apply(that, [input, game, recon, lock]);
                            },
                            get: function(target, key) {
                                const value = Reflect.get(target, key)
                                return key === isProxy ? true : value;
                            },
                        })
                    }

                    RENDER(three, utils, colors, config, overlay, scale, game, controls, renderer, me, delta);
                }

                const featureWallbangs = getFeature('Wallbangs');
                if (! game.map.manager.addBlock[isProxy]) {
                    game.map.manager.addBlock = new Proxy(game.map.manager.addBlock, {
                        apply: function(target, that, args) {
                            if (args[7] && args[7].penetrable) {
                                args[7].transparent = featureWallbangs.value ? true : false;
                                args[7].opacity = featureWallbangs.value ? 0.75 : 1.0;
                            }
                            return target.apply(that, args);
                        },
                        get: function(target, key) {
                            const value = Reflect.get(target, key)
                            return key === isProxy ? true : value;
                        }
                    })
                }

                if (objectDirty) {
                    game.map.manager.objects.filter(x => {
                        return x.penetrable
                    }).map((obj, index, array) => {
                        obj.transparent = featureWallbangs.value ? true : false;
                        obj.opacity = featureWallbangs.value ? 0.75 : 1.0;
                    });
                    objectDirty = false;
                }

                return target.apply(that, [scale, game, controls, renderer, me, delta]);
            }
        });
    }

    window.WebSocket = new Proxy(window.WebSocket, {
        construct: function(target, args) {

            const ws = new target(...args);

            // WebSocket "onopen"
            const openHandler = (event) => {
                console.log('Open', event);
            };

            // WebSocket "onmessage"
            const messageHandler = (event) => {
                let typedArray = new Uint8Array(event.data);
                let [id, ...data] = window.msgpack.decode(typedArray);

                switch (id)
                {
                    case "k":
                        {
                            const sz = data[1];
                            const el = data[0];
                            const al = 0x203300F;
                            const mp = 0x3e8;
                            for (let i = 0; i < el.length; ++ i) {
                                if(i == 0 || i % sz == 0) {
                                    let sid = el[i];
                                    let pos = {x:0,y:0,z:0};
                                    pos.x = (el[i + 1] ^ al) / mp
                                    pos.y = (el[i + 2] ^ al) / mp
                                    pos.z = (el[i + 3] ^ al) / mp
                                    positions.set(sid, pos);
                                }
                            }
                        }
                        break;
                }
                // Not changing any data so this is not used atm
                //typedArray = window.msgpack.encode([id, ...data]);
                //Object.defineProperty(event, 'data', {
                //    value: typedArray.buffer
                //});
            };

            // WebSocket "onclose"
            const closeHandler = (event) => {
                console.log('Close', event);
                // remove event listeners
                ws.removeEventListener('open', openHandler);
                ws.removeEventListener('message', messageHandler);
                ws.removeEventListener('close', closeHandler);
            };

            // add event listeners
            ws.addEventListener('open', openHandler);
            ws.addEventListener('message', messageHandler);
            ws.addEventListener('close', closeHandler);

            // proxied send
            ws.send = new Proxy(ws.send, {
                apply: function(target, that, args) {
                    //console.log('Send', args);
                    target.apply(that, args);
                }
            });

            return ws;
        }
    })

    Response.prototype.arrayBuffer = new Proxy(Response.prototype.arrayBuffer, {
        apply: function(target, that, args) {
            const returnValue = target.apply(that, args);
            returnValue.then(buffer => {
                script = decodeText("", new DataView(buffer), 0x69);
                setVars();
                initialize();
            });
            return returnValue;
        }
    })

    Object.freeze = new Proxy(Object.freeze, {
        apply: function(target, that, args) {
            let Caller = arguments.callee.caller;
            if (Caller && Caller.arguments.length == 5 && Caller.arguments[0].ACESFilmicToneMapping) {
                hookChain(...Caller.arguments);
                Object.freeze = target;
            }
            return target.apply(that, args);
        }
    });

    /* Backup Method
    window.TextDecoder.prototype.decode = new Proxy(window.TextDecoder.prototype.decode, {
        apply: function(target, that, args) {
            let returnValue = target.apply(that, args);
            if (returnValue.length > 1050000) {
                script = returnValue;
                setVars();
                initialize();
            }
            return returnValue;
        }
    })
    */

    /* Future Exploit
    Object.setPrototypeOf = new Proxy(Object.setPrototypeOf, {
        apply: function(target, that, args) {
            if (args[0].isPlayer) {
                args[0].module = args[1].$$;
                console.dir(args)
            }
            return target.apply(that, args);
        }
    });
    */
})();
